import{a as o,t as a}from"./disclose-version.dX1e3oqb.js";import"./legacy.B9kJBAmk.js";import{n as r}from"./runtime.DnGnsA3j.js";const h={title:"An Analytics Service in Elixir",summary:"Where I get misty eyed about building my own analytics stack",date:"2017-02-15T00:00:00.000Z"};var i=a('<p>Ever since I learned about <a href="http://elixir-lang.org/" rel="nofollow">Elixir</a> I’ve been curious about whether it would be feasible to build a service in it for receiving analytics events and pushing them to Redshift like <a href="http://snowplowanalytics.com/" rel="nofollow">Snowplow</a> or <a href="https://segment.com/" rel="nofollow">Segment</a>.</p> <p>There are a few challenges that a proposed new service would have to solve, alongside the core job of receiving POST requests, writing the passed events to S3, and copying them regularly to Redshift (where they can be analyzed or built upon).</p> <p>⭐️ <strong>Throughput:</strong> Analytics on a site like <a href="https://www.artsy.net" rel="nofollow">Artsy</a> aren’t anything like Twitter or Facebook, but we have enough concurrent users on the site— and enough instrumentation — that a proposed API would have to be able to handle a thousands of concurrent events per second without breaking a sweat.</p> <p>⭐️ <strong>Dynamic Schemas:</strong> Analytics events can have different properties that can be difficult to represent in a fixed columnar schema. Snowplow solved this problem by sticking to a very strict <a href="http://snowplowanalytics.com/blog/2013/08/12/towards-universal-event-analytics-building-an-event-grammar/" rel="nofollow">Subject-Verb-Object</a> schema.</p> <p>Segment handles it by splitting warehoused data into two parts: a singular, monolithic <code>tracks</code> table that has only the basic information, and separate <a href="https://segment.com/docs/warehouses/schema/#event-tables" rel="nofollow">event tables</a> that have a column for each property passed for that specific event. Developers at Artsy have found that the ability to pass arbitrary JSON payloads makes instrumentation much easier to implement. I’m on the fence about how much value this really adds, but it is a cool feature.</p> <p>⭐️ <strong>Availability:</strong> This is tied to throughput but it goes without saying any service would need to have high availability. Events can’t be dropped willy-nilly, or we’d have unreliable data with which to train our models and make our business decisions. Elixir/Erlang’s reputation for availability is a big part of my interest in it.</p> <p>⭐️ <strong>Easy to deploy:</strong> A gripe I have with Snowplow is that it is (or was) a series of five applications housed in a single git repository. It was hard to understand what code did what. Segment of course is the total opposite: you pay them to host it for you so it’s plug and play. This really is the best solution for any company where resources are scant, but I’m curious whether this is something we really need to pay for.</p> <p>⭐️ <strong>Literate code:</strong> Another Scala gripe, but I find it <em>impossible</em> to grok. I heard someone joke about how Scala has a philosophy of “write it once, read it never”. Since I started programming in Ruby I’ve come to strongly believe in simple control flows and obvious naming over code that is tightly optimized (for space or speed). Elixir has some promise of offering both.</p> <p>⭐️ <strong>Modularity:</strong> It is cool how Snowplow offers <a href="https://github.com/snowplow/snowplow/tree/master/3-enrich" rel="nofollow">Enrichment</a> as a step in their process. We have many processes in our own ETL flow that do this, for instance transforming referrer urls (for which we use <a href="https://github.com/snowplow/referer-parser" rel="nofollow">a Snowplow library</a>). I’d love to just be able to plug in a module as needed to get e.g. geo-ip enrichment, or user-agent parsing.</p> <h2>Next Steps</h2> <p>The requirements for this are pretty daunting, but I want to play with two ideas for processing events: using <a href="https://www.rabbitmq.com/getstarted.html" rel="nofollow">RabbitMQ</a> to queue the events, and using Elixir’s own <a href="https://github.com/elixir-lang/gen_stage" rel="nofollow">GenStage</a> (or <a href="https://github.com/elixir-lang/flow" rel="nofollow">Flow?</a>). In particular I’m curious how they compare in terms of scalability / throughput. In my next post I’ll describe a very simple RabbitMQ / <a href="http://www.phoenixframework.org/" rel="nofollow">Phoenix</a> setup.</p>',1);function p(e){var t=i();r(20),o(e,t)}export{p as default,h as metadata};
